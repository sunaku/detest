%#----------------------------------------------------------------------------
## SYNOPSIS
%#----------------------------------------------------------------------------

`dfect` [<OPTIONS>] (<FILE>|<GLOB>) ...

%#----------------------------------------------------------------------------
## DESCRIPTION
%#----------------------------------------------------------------------------

Evaluates the given <FILE>s and also files matching the given <GLOB> patterns.

The exit status of this command reflects the number of errors and assertion
failures up to a maximum of 255 (to avoid 8-bit unsigned integer overflow).

%#----------------------------------------------------------------------------
## OPTIONS
%#----------------------------------------------------------------------------

* `-d`, `--debug`:
  Launch interactive debugger upon assertion failures.

* `-q`, `--quiet`:
  Do not print execution report.

* `-h`, `--help`:
  Display this manual and exit.

* `-v`, `--version`:
  Print version number and exit.

%#--------------------------------------------------------------------------
## ASSERTIONS
%#--------------------------------------------------------------------------

The following methods accept a block parameter and assert something about the
result of executing that block.  They also accept an optional message, which
is shown in failure reports (see **Failures** below) if they fail.

* `T()`:
  assert true (not `nil` and not `false`)

* `F()`:
  assert not true (`nil` or `false`)

* `E()`:
  assert that an execption is raised

* `C()`:
  assert that a symbol is thrown

%#------------------------------------------------------------------------
### Negation
%#------------------------------------------------------------------------

The following methods are the *opposite* of normal assertions.  They also
accept an optional message, which is shown in failure reports (see
**Failures** below) if they fail.

* `T!()`:
  same as `F()`

* `F!()`:
  same as `T()`

* `E!()`:
  assert that an exception is *not* raised

* `C!()`:
  assert that a symbol is *not* thrown

%#------------------------------------------------------------------------
### Sampling
%#------------------------------------------------------------------------

The following methods let you *check the outcome* of an assertion without
recording a success or failure in the test execution report.

* `T?()`:
  returns true if `T()` passes; false otherwise

* `F?()`:
  returns true if `F()` passes; false otherwise

* `E?()`:
  returns true if `E()` passes; false otherwise

* `C?()`:
  returns true if `C()` passes; false otherwise

%#------------------------------------------------------------------------
### Failures
%#------------------------------------------------------------------------

When an assertion fails, details about the failure will be shown:

    - fail: block must yield true (!nil && !false)
      code: |-
        [12..22] in test/simple.rb
           12
           13     D "with more nested tests" do
           14       x = 5
           15
           16       T { x > 2 }   # passes
        => 17       F { x > 2 }   # fails
           18       E { x.hello } # passes
           19     end
           20   end
           21
           22   # equivalent of before(:each) or setup()
      vars:
        x: 5
        y: 83
      call:
      - test/simple.rb:17
      - test/simple.rb:3

You will then be placed into a debugger to investigate the failure if
the `:debug` option is enabled in the `Dfect.options` hash.

Details about all assertion failures and a trace of all tests executed
are stored by Dfect and provided by the `Dfect.report()` method.

%#--------------------------------------------------------------------------
## TESTS
%#--------------------------------------------------------------------------

The `D()` method defines a new Dfect **test**, which is analagous to the
concept of **test case** in xUnit or **describe** in rSpec.  A test may
contain nested tests.

    D "outer test" do
      # assertions and logic here

      D "inner test" do
        # more assertions and logic here
      end
    end

%#------------------------------------------------------------------------
### Execution
%#------------------------------------------------------------------------

Tests are executed in depth-first order.

You can configure the test execution process using:

    Dfect.options = your_options_hash

You can execute all tests defined thus far using:

    Dfect.run

You can stop the execution at any time using:

    Dfect.stop

You can view the results of execution using:

    puts Dfect.report.to_yaml

You can mix-in the `Dfect` module into your program and execute all tests
defined by your program before it terminates by simply adding the following
line at the top of your program:

    require 'dfect/auto'

See the API documentation for more information and examples.

%#----------------------------------------------------------------------
### Hooks
%#----------------------------------------------------------------------

The `D()` method provides several entry points (hooks) into the test
execution process:

    D "outer test" do
      D .<  { puts "before each nested test" }
      D .>  { puts "after  each nested test" }
      D .<< { puts "before all nested tests" }
      D .>> { puts "after  all nested tests" }

      D "inner test" do
        # assertions and logic here
      end
    end

A hook method may be called multiple times.  Each call registers
additional logic to execute during the hook:

    D .< { puts "do something" }
    D .< { puts "do something more!" }

%#----------------------------------------------------------------------
### Logging
%#----------------------------------------------------------------------

The `L()` method lets you insert log messages, composed of arbitrary
Ruby objects, into the test execution report.

%#----------------------------------------------------------------------------
### Sharing
%#----------------------------------------------------------------------------

* `S()`:
  Mechanism for sharing code.  When called with a block, it shares the given
  block (under a given identifier) for injection into other tests.  When
  called without a block, it injects a previously shared block (under a given
  identifier) into the environment where it is called.

* `S!()`:
  Combination of the two uses of the `S()` method: it lets you simultaneously
  share a block of code while injecting it into the environment where that
  method is called.

* `S?()`:
  Checks whether any code has been shared under a given identifier.

%#------------------------------------------------------------------------
### Insulation
%#------------------------------------------------------------------------

The `D!()` method defines a new test that is explicitly insulated from
the tests that contain it and also from the top-level Ruby environment.
Root-level calls to the `D()` method are insulated by default.

Inside an insulated test, you are free to mix-in any modules your test
logic needs and also define your own constants, methods, and classes.

%#------------------------------------------------------------------------
## EMULATION
%#------------------------------------------------------------------------

Dfect provides emulation layers for several popular testing libraries:

* dfect/unit:
  [Test::Unit] emulation layer

* dfect/mini:
  [Minitest] emulation layer

* dfect/spec:
  [RSpec] emulation layer

Simply load one of these emulation layers into your test suite and you can
write your tests using the familiar syntax of that testing library.  See
their source code for more information.

