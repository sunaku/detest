%#----------------------------------------------------------------------------
## TESTS
%#----------------------------------------------------------------------------

The `D()` method creates a new **test**, which is analagous to the `describe`
keyword in [RSpec] and the concept of a "test case" in [xUnit].  A test may
contain nested tests (see **Insulation** below).

    D "outer test" do
      # assertions and logic here

      D "inner test" do
        # more assertions and logic here
      end
    end

%#----------------------------------------------------------------------------
### Hooks
%#----------------------------------------------------------------------------

A **hook** is a scheduled point of entry into the test execution process.  The
following **hook methods** allow you to register a block of code to execute
when a hook occurs:

* `D.<()`:
  Calls the given block *before each* child test.

* `D.>()`:
  Calls the given block *after each* child test.

* `D.<<()`:
  Calls the given block *before all* child tests.

* `D.>>()`:
  Calls the given block *after all* child tests.

A hook method can be called multiple times.  Each additional call schedules
more logic to be executed during the hook:

    D .< { puts "do something" }
    D .< { puts "do something more!" }

%#----------------------------------------------------------------------------
### Insulation
%#----------------------------------------------------------------------------

The `D!()` method defines a new test that is explicitly insulated from
the tests that contain it and also from the top-level Ruby environment.
Root-level calls to the `D()` method are insulated by default.

Inside an insulated test, you are free to mix-in (using the `extend` keyword,
not the `include` keyword) any modules your test logic needs and also define
your own constants, methods, and classes.

%#----------------------------------------------------------------------------
### Sharing
%#----------------------------------------------------------------------------

* `S()`:
  Mechanism for sharing code.  When called with a block, it shares the given
  block (under a given identifier) for injection into other tests.  When
  called without a block, it injects a previously shared block (under a given
  identifier) into the environment where it is called.

* `S!()`:
  Combination of the two uses of the `S()` method: it lets you simultaneously
  share a block of code while injecting it into the environment where that
  method is called.

* `S?()`:
  Checks whether any code has been shared under a given identifier.

%#----------------------------------------------------------------------------
### Information
%#----------------------------------------------------------------------------

* `I()`:
  Mechanism for inserting arbitrary Ruby objects into the test execution
  report.  You can think of this method as a way to *inform* yourself.

* `I!()`:
  Starts the interactive debugger at the location where it is called.

%#----------------------------------------------------------------------------
### Execution
%#----------------------------------------------------------------------------

Tests are executed in depth-first search (DFS) order.

You can configure the test execution process using:

    DIFECTS.debug = your_choice_here

You can execute all tests defined thus far using:

    DIFECTS.start

You can stop the execution at any time using:

    DIFECTS.stop

You can view the results of execution using:

    puts DIFECTS.trace.to_yaml
    puts DIFECTS.stats.to_yaml

You can mix-in the `DIFECTS` module into your program and execute all tests
defined by your program before it terminates by simply adding the following
line at the top of your program:

    require 'difects/auto'

See the API documentation for more information and examples.
